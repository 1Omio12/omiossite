<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>ORadiation Dual Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Roboto', sans-serif; background: #cde5fc; color: #2d3748; margin: 0; padding: 2rem; min-height: 100vh; display: flex; flex-direction: column; }
    .container { max-width: 1400px; margin: 0 auto; flex: 1; }
    h1 { font-size: 2.5rem; font-weight: 700; color: #1a202c; text-align: center; margin-bottom: 1rem; }
    h2 { font-size: 1.75rem; font-weight: 500; color: #2d3748; margin-bottom: 1.5rem; text-align: center; }
    .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 2rem; padding: 1.5rem; background: #ffffff; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); }
    .controls { display: flex; gap: 1.5rem; flex-wrap: wrap; justify-content: center; align-items: center; background: #ffffff; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
    .controls label { font-size: 1rem; font-weight: 500; color: #4a5568; }
    .controls input { padding: 0.75rem; font-size: 1rem; border: 1px solid #e2e8f0; border-radius: 0.5rem; width: 140px; transition: border-color 0.3s ease, box-shadow 0.3s ease; }
    .controls input:focus { outline: none; border Patricecolor: #3182ce; box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1); }
    .controls button { background: #3182ce; color: #ffffff; padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 500; border-radius: 0.5rem; border: none; cursor: pointer; transition: background 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; }
    .controls button:hover { background: #2b6cb0; }
    .chart-container { background: #ffffff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
    #circle-map, #heat-map { height: 600px; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
    .info { font-size: 0.875rem; color: #718096; text-align: center; }
    .legend { background: #ffffff; padding: 1.5rem; border-radius: 0.75rem; font-size: 0.875rem; color: #4a5568; width: 100%; max-width: 250px; }
    .legend-container { background: #ffffff; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); }
    .legend-toggle { background: #3182ce; color: #ffffff; width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; font-size: 0.875rem; font-weight: 500; cursor: pointer; text-align: center; transition: background 0.3s ease; user-select: none; touch-action: none; -webkit-tap-highlight-color: transparent; }
    .legend-toggle:hover { background: #2b6cb0; }
    .legend-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
    .legend-content.legend-open { max-height: 500px; }
    .legend-item { display: flex; align-items: center; margin-bottom: 0.75rem; }
    .legend i { width: 16px; height: 16px; margin-right: 0.75rem; flex-shrink: 0; }
    .legend img { width: 16px; height: 16px; margin-right: 0.75rem; vertical-align: middle; }
    .legend button { background: #3182ce; color: #ffffff; width: 100%; padding: 0.75rem; margin-top: 1rem; border-radius: 0.5rem; border: none; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background 0.3s ease; user-select: none; -webkit-tap-highlight-color: transparent; }
    .legend button:hover { background: #2b6cb0; }
    #detector-container { margin: 2rem auto; width: 300px; height: 600px; display: flex; justify-content: center; align-items: center; background: #ffffff; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); }
    #detector-svg { width: 100%; height: 100%; }
    .detector-body { fill: #edf2f7; stroke: #4a5568; stroke-width: 2; }
    .detector-antenna { fill: #2d3748; stroke: #2d3748; stroke-width: 2; }
    .detector-screen { fill: #e6fffa; stroke: #4a5568; stroke-width: 1; filter: url(#glow); }
    .detector-button { fill: #3182ce; stroke: #2d3748; stroke-width: 2; }
    .detector-text { font-family: 'Courier New', Courier, monospace; font-size: 12px; fill: #2d3748; text-anchor: middle; dominant-baseline: middle; }
    .detector-light { fill: #edf2f7; transition: fill 0.3s ease; }
    .footer { text-align: center; font-size: 0.875rem; color: #718096; padding: 1rem 0; margin-top: auto; }
  </style>
</head>
<body>
  <div class="header">
    <img src="Military_Institute_of_Science_and_Technology_Monogram.svg.png" alt="MIST Logo" class="h-14 rounded-lg shadow-sm" />
    <h1><b><big>|| OMIO'S RADIATION MONITORING SYSTEM ||</b></h1>
    <div class="w-14"></div>
  </div>

  <div class="container">
    <div id="detector-container">
      <svg id="detector-svg" viewBox="0 0 150 300">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
            <feFlood flood-color="#3b82f6" flood-opacity="0.3"/>
            <feComposite in2="blur" operator="in"/>
            <feMerge>
              <feMergeNode/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
        <rect x="65" y="10" width="20" height="20" class="detector-antenna"/>
        <line x1="75" y1="10" x2="75" y2="5" class="detector-antenna"/>
        <rect x="30" y="30" width="90" height="120" rx="10" class="detector-body"/>
        <text x="75" y="165" class="detector-text" style="font-size: 14px;">DETECTOR</text>
        <rect x="35" y="40" width="80" height="50" rx="5" class="detector-screen"/>
        <text x="75" y="65" class="detector-text" id="detector-display">N/A µSv/h</text>
        <image x="58" y="102" width="35" height="35" href="trifoil1-modified.png" />
        <circle cx="75" cy="100" r="2" class="detector-light" id="detector-light"/>
      </svg>
    </div>

    <!-- Circle Marker Map Section -->
    <div class="controls">
      <label for="circle-points" class="font-medium">Number of Data Points (Circle Map):</label>
      <input type="number" id="circle-points" min="1" max="8000" value="8000" class="focus:ring focus:ring-blue-200"/>
      <label for="circle-start-date" class="font-medium">Start Date:</label>
      <input type="date" id="circle-start-date" class="focus:ring focus:ring-blue-200"/>
      <label for="circle-start-time" class="font-medium">Start Time:</label>
      <input type="time" id="circle-start-time" class="focus:ring focus:ring-blue-200"/>
      <label for="circle-end-date" class="font-medium">End Date:</label>
      <input type="date" id="circle-end-date" class="focus:ring focus:ring-blue-200"/>
      <label for="circle-end-time" class="font-medium">End Time:</label>
      <input type="time" id="circle-end-time" class="focus:ring focus:ring-blue-200"/>
      <label for="circle-min-value" class="font-medium">Min Value (µSv/h):</label>
      <input type="number" id="circle-min-value" step="0.1" value="0" class="focus:ring focus:ring-blue-200" oninput="updateCircleRange(this.value, document.getElementById('circle-max-value').value, true)"/>
      <label for="circle-max-value" class="font-medium">Max Value (µSv/h):</label>
      <input type="number" id="circle-max-value" step="0.1" value="10" class="focus:ring focus:ring-blue-200" oninput="updateCircleRange(document.getElementById('circle-min-value').value, this.value, true)"/>
      <button onclick="searchCircleData()">Search Time Range</button>
      <button onclick="updateCircleMap()">Update Data</button>
    </div>

    <div class="chart-container">
      <canvas id="circle-radiationChart"></canvas>
    </div>

    <h2>Radiation Mapping Dashboard (Circle Markers)</h2>
    <div id="circle-map"></div>
    <p class="info">Circle map updates automatically every 5 seconds unless time range is set.</p>

    <!-- Heatmap Section -->
    <div class="controls">
      <label for="heat-points" class="font-medium">Number of Data Points (Heatmap):</label>
      <input type="number" id="heat-points" min="1" max="8000" value="8000" class="focus:ring focus:ring-blue-200"/>
      <label for="heat-start-date" class="font-medium">Start Date:</label>
      <input type="date" id="heat-start-date" class="focus:ring focus:ring-blue-200"/>
      <label for="heat-start-time" class="font-medium">Start Time:</label>
      <input type="time" id="heat-start-time" class="focus:ring focus:ring-blue-200"/>
      <label for="heat-end-date" class="font-medium">End Date:</label>
      <input type="date" id="heat-end-date" class="focus:ring focus:ring-blue-200"/>
      <label for="heat-end-time" class="font-medium">End Time:</label>
      <input type="time" id="heat-end-time" class="focus:ring focus:ring-blue-200"/>
      <label for="heat-min-value" class="font-medium">Min Value (µSv/h):</label>
      <input type="number" id="heat-min-value" step="0.1" value="0" class="focus:ring focus:ring-blue-200" oninput="updateHeatRange(this.value, document.getElementById('heat-max-value').value, true)"/>
      <label for="heat-max-value" class="font-medium">Max Value (µSv/h):</label>
      <input type="number" id="heat-max-value" step="0.1" value="10" class="focus:ring focus:ring-blue-200" oninput="updateHeatRange(document.getElementById('heat-min-value').value, this.value, true)"/>
      <button onclick="searchHeatData()">Search Time Range</button>
      <button onclick="updateHeatMap()">Update Data</button>
    </div>

    <div class="chart-container">
      <canvas id="heat-radiationChart"></canvas>
    </div>

    <h2>Radiation Heatmap Dashboard</h2>
    <div id="heat-map"></div>
    <p class="info">Heatmap updates automatically every 5 seconds unless time range is set.</p>
  </div>

  <div class="footer">
    Created by OMIO | © 2025
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
  <script>
    // Global array to store heatmap data points
    let heatDataPoints = [];

    // IDW Interpolation Function
    function interpolateIDW(lat, lon, points, power = 2, maxDistance = 0.01, maxPoints = 10) {
      // Find k-nearest points to improve performance
      const distances = points.map(point => ({
        point,
        distance: Math.sqrt(Math.pow(lat - point.lat, 2) + Math.pow(lon - point.lon, 2))
      })).filter(d => d.distance <= maxDistance && d.distance > 0); // Exclude exact matches

      // Sort by distance and take top maxPoints
      distances.sort((a, b) => a.distance - b.distance);
      const nearest = distances.slice(0, maxPoints);

      if (nearest.length === 0) return null; // No points within range

      let sumValue = 0;
      let sumWeight = 0;

      nearest.forEach(({ point, distance }) => {
        const weight = 1 / Math.pow(distance, power);
        sumValue += weight * point.val;
        sumWeight += weight;
      });

      return sumValue / sumWeight;
    }

    // Circle Marker Map Setup
    const circleMap = L.map('circle-map').setView([23.685, 90.3563], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(circleMap);

    const circleMarkers = L.layerGroup().addTo(circleMap);
    let circleLatestValidFeed = null;
    let circleIsInitialLoad = true;
    let circleMinValue = 0;
    let circleMaxValue = 10;

    const circleLegend = L.control({position: 'bottomright'});
    circleLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend-container');
      div.innerHTML = `
        <button class="legend-toggle">Toggle Legend</button>
        <div class="legend-content">
          <div class="legend" id="circle-legend-content">
            <div class="legend-item">
              <i style="background:#3b82f6"></i>
              <span>${circleMinValue.toFixed(1)} to ${(circleMinValue + (circleMaxValue - circleMinValue) * 0.2).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#06b6d4"></i>
              <span>${(circleMinValue + (circleMaxValue - circleMinValue) * 0.2).toFixed(1)} to ${(circleMinValue + (circleMaxValue - circleMinValue) * 0.4).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#22c55e"></i>
              <span>${(circleMinValue + (circleMaxValue - circleMinValue) * 0.4).toFixed(1)} to ${(circleMinValue + (circleMaxValue - circleMinValue) * 0.6).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#facc15"></i>
              <span>${(circleMinValue + (circleMaxValue - circleMinValue) * 0.6).toFixed(1)} to ${(circleMinValue + (circleMaxValue - circleMinValue) * 0.8).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#ef4444"></i>
              <span>${(circleMinValue + (circleMaxValue - circleMinValue) * 0.8).toFixed(1)} to ${circleMaxValue.toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <img src="https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png" />
              <span>Latest Location</span>
            </div>
            <button id="circle-show-latest-location">Show Latest Location</button>
          </div>
        </div>
      `;
      const toggleButton = div.querySelector('.legend-toggle');
      const showLatestButton = div.querySelector('#circle-show-latest-location');
      
      L.DomEvent.on(toggleButton, 'click touchstart', function (e) {
        e.preventDefault();
        const content = div.querySelector('.legend-content');
        content.classList.toggle('legend-open');
      });

      L.DomEvent.on(showLatestButton, 'click touchstart', function (e) {
        e.preventDefault();
        if (circleLatestValidFeed) {
          const lat = parseFloat(circleLatestValidFeed.field4);
          const lon = parseFloat(circleLatestValidFeed.field5);
          const val = parseFloat(circleLatestValidFeed.field3);
          const time = circleLatestValidFeed.created_at;

          const customIcon = L.icon({
            iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34]
          });

          L.marker([lat, lon], { icon: customIcon })
            .addTo(circleMarkers)
            .bindPopup(`Latest Location<br>Radiation: ${val} µSv/h<br>Time: ${time}`);

          circleMap.panTo([lat, lon], { animate: true, duration: 1 });
        } else {
          alert('No valid latest location available.');
        }
      });
      return div;
    };
    circleLegend.addTo(circleMap);

    const circleCtx = document.getElementById('circle-radiationChart').getContext('2d');
    const circleRadiationChart = new Chart(circleCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Radiation Level (µSv/h)',
          data: [],
          borderColor: '#3182ce',
          backgroundColor: 'rgba(49, 130, 206, 0.2)',
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'Radiation Level Over Time (Circle Map)',
            font: { size: 20, family: 'Roboto' },
            padding: { top: 10, bottom: 20 }
          }
        },
        scales: {
          x: {
            type: 'time',
            title: { display: true, text: 'Time', font: { family: 'Roboto' } }
          },
          y: {
            title: { display: true, text: 'Radiation Level (µSv/h)', font: { family: 'Roboto' } }
          }
        }
      }
    });

    // Heatmap Setup
    const heatMap = L.map('heat-map').setView([23.685, 90.3563], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(heatMap);

    let heatLayer = L.heatLayer([], {
      radius: 50,
      blur: 40,
      minOpacity: 0.4,
      maxZoom: 17,
      gradient: {
        0.0: '#3b82f6',  // Blue
        0.2: '#06b6d4',  // Cyan
        0.4: '#22c55e',  // Green
        0.6: '#facc15',  // Yellow
        1.0: '#f10f05'   // Red
      }
    }).addTo(heatMap);

    let heatLatestValidFeed = null;
    let heatIsInitialLoad = true;
    let heatMinValue = 0;
    let heatMaxValue = 10;

    // Updated Heatmap Click Handler with IDW
    heatMap.on('click', function(e) {
      const clickedLat = e.latlng.lat;
      const clickedLon = e.latlng.lng;

      // Compute interpolated value using IDW
      const interpolatedValue = interpolateIDW(clickedLat, clickedLon, heatDataPoints, 2, 0.01, 10);

      // Find nearest point for comparison
      let minDist = Infinity;
      let closestPoint = null;

      heatDataPoints.forEach(point => {
        const distance = Math.sqrt(
          Math.pow(clickedLat - point.lat, 2) + Math.pow(clickedLon - point.lon, 2)
        );
        if (distance < minDist) {
          minDist = distance;
          closestPoint = point;
        }
      });

      // Prepare popup content
      let popupContent = '';
      if (interpolatedValue !== null) {
        popupContent += `Interpolated radiation: ${interpolatedValue.toFixed(3)} µSv/h`;
      }
      if (closestPoint) {
        popupContent += `${popupContent ? '<br>' : ''}Nearest radiation: ${closestPoint.val.toFixed(3)} µSv/h<br>Time: ${closestPoint.time}`;
      }
      if (!popupContent) {
        popupContent = 'No data points within range.';
      }

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupContent)
        .openOn(heatMap);
    });

    const heatLegend = L.control({position: 'bottomright'});
    heatLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend-container');
      div.innerHTML = `
        <button class="legend-toggle">Toggle Legend</button>
        <div class="legend-content">
          <div class="legend" id="heat-legend-content">
            <div class="legend-item">
              <i style="background:#3b82f6"></i>
              <span>${heatMinValue.toFixed(1)} to ${(heatMinValue + (heatMaxValue - heatMinValue) * 0.2).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#06b6d4"></i>
              <span>${(heatMinValue + (heatMaxValue - heatMinValue) * 0.2).toFixed(1)} to ${(heatMinValue + (heatMaxValue - heatMinValue) * 0.4).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#22c55e"></i>
              <span>${(heatMinValue + (heatMaxValue - heatMinValue) * 0.4).toFixed(1)} to ${(heatMinValue + (heatMaxValue - heatMinValue) * 0.6).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#facc15"></i>
              <span>${(heatMinValue + (heatMaxValue - heatMinValue) * 0.6).toFixed(1)} to ${(heatMinValue + (heatMaxValue - heatMinValue) * 0.8).toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <i style="background:#ef4444"></i>
              <span>${(heatMinValue + (heatMaxValue - heatMinValue) * 0.8).toFixed(1)} to ${heatMaxValue.toFixed(1)} µSv/h</span>
            </div>
            <div class="legend-item">
              <img src="https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png" />
              <span>Latest Location</span>
            </div>
            <button id="heat-show-latest-location">Show Latest Location</button>
          </div>
        </div>
      `;
      const toggleButton = div.querySelector('.legend-toggle');
      const showLatestButton = div.querySelector('#heat-show-latest-location');

      L.DomEvent.on(toggleButton, 'click touchstart', function (e) {
        e.preventDefault();
        const content = div.querySelector('.legend-content');
        content.classList.toggle('legend-open');
      });

      L.DomEvent.on(showLatestButton, 'click touchstart', function (e) {
        e.preventDefault();
        if (heatLatestValidFeed) {
          const lat = parseFloat(heatLatestValidFeed.field4);
          const lon = parseFloat(heatLatestValidFeed.field5);
          const val = parseFloat(heatLatestValidFeed.field3);
          const time = heatLatestValidFeed.created_at;

          const customIcon = L.icon({
            iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34]
          });

          L.marker([lat, lon], { icon: customIcon })
            .addTo(heatMap)
            .bindPopup(`Latest Location<br>Radiation: ${val} µSv/h<br>Time: ${time}`);

          heatMap.panTo([lat, lon], { animate: true, duration: 1 });
        } else {
          alert('No valid latest location available.');
        }
      });
      return div;
    };
    heatLegend.addTo(heatMap);

    const heatCtx = document.getElementById('heat-radiationChart').getContext('2d');
    const heatRadiationChart = new Chart(heatCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Radiation Level (µSv/h)',
          data: [],
          borderColor: '#3182ce',
          backgroundColor: 'rgba(49, 130, 206, 0.2)',
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'Radiation Level Over Time (Heatmap)',
            font: { size: 20, family: 'Roboto' },
            padding: { top: 10, bottom: 20 }
          }
        },
        scales: {
          x: {
            type: 'time',
            title: { display: true, text: 'Time', font: { family: 'Roboto' } }
          },
          y: {
            title: { display: true, text: 'Radiation Level (µSv/h)', font: { family: 'Roboto' } }
          }
        }
      }
    });

    function getColor(value, minVal, maxVal) {
      const normalized = (value - minVal) / (maxVal - minVal);
      if (normalized <= 0.2) return '#3b82f6';  // Blue
      if (normalized <= 0.4) return '#06b6d4';  // Cyan
      if (normalized <= 0.6) return '#22c55e';  // Green
      if (normalized <= 0.8) return '#facc15';  // Yellow
      return '#ef4444';                         // Red
    }

    function updateLegend(minVal, maxVal, isCircle) {
      const legendContent = document.getElementById(`${isCircle ? 'circle' : 'heat'}-legend-content`);
      if (legendContent) {
        const colors = ['#3b82f6', '#06b6d4', '#22c55e', '#facc15', '#ef4444'];
        legendContent.innerHTML = `
          <div class="legend-item">
            <i style="background:${colors[0]}"></i>
            <span>${minVal.toFixed(1)} to ${(minVal + (maxVal - minVal) * 0.2).toFixed(1)} µSv/h</span>
          </div>
          <div class="legend-item">
            <i style="background:${colors[1]}"></i>
            <span>${(minVal + (maxVal - minVal) * 0.2).toFixed(1)} to ${(minVal + (maxVal - minVal) * 0.4).toFixed(1)} µSv/h</span>
          </div>
          <div class="legend-item">
            <i style="background:${colors[2]}"></i>
            <span>${(minVal + (maxVal - minVal) * 0.4).toFixed(1)} to ${(minVal + (maxVal - minVal) * 0.6).toFixed(1)} µSv/h</span>
          </div>
          <div class="legend-item">
            <i style="background:${colors[3]}"></i>
            <span>${(minVal + (maxVal - minVal) * 0.6).toFixed(1)} to ${(minVal + (maxVal - minVal) * 0.8).toFixed(1)} µSv/h</span>
          </div>
          <div class="legend-item">
            <i style="background:${colors[4]}"></i>
            <span>${(minVal + (maxVal - minVal) * 0.8).toFixed(1)} to ${maxVal.toFixed(1)} µSv/h</span>
          </div>
          <div class="legend-item">
            <img src="https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png" />
            <span>Latest Location</span>
          </div>
          <button id="${isCircle ? 'circle' : 'heat'}-show-latest-location">Show Latest Location</button>
        `;
        const showLatestButton = legendContent.querySelector(`#${isCircle ? 'circle' : 'heat'}-show-latest-location`);
        L.DomEvent.on(showLatestButton, 'click touchstart', function (e) {
          e.preventDefault();
          const latestFeed = isCircle ? circleLatestValidFeed : heatLatestValidFeed;
          if (latestFeed) {
            const lat = parseFloat(latestFeed.field4);
            const lon = parseFloat(latestFeed.field5);
            const val = parseFloat(latestFeed.field3);
            const time = latestFeed.created_at;

            const customIcon = L.icon({
              iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34]
            });

            L.marker([lat, lon], { icon: customIcon })
              .addTo(isCircle ? circleMarkers : heatMap)
              .bindPopup(`Latest Location<br>Radiation: ${val} µSv/h<br>Time: ${time}`);

            (isCircle ? circleMap : heatMap).panTo([lat, lon], { animate: true, duration: 1 });
          } else {
            alert('No valid latest location available.');
          }
        });
      }
    }

    function updateCircleRange(minVal, maxVal, forceUpdate = false) {
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      circleMinValue = parseFloat(minVal);
      circleMaxValue = parseFloat(maxVal);
      updateLegend(circleMinValue, circleMaxValue, true);
      if (forceUpdate) {
        fetchCircleData(document.getElementById('circle-points').value, null, null, null, null, circleMinValue, circleMaxValue, true);
      }
    }

    function updateHeatRange(minVal, maxVal, forceUpdate = false) {
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      heatMinValue = parseFloat(minVal);
      heatMaxValue = parseFloat(maxVal);
      updateLegend(heatMinValue, heatMaxValue, false);
      if (forceUpdate) {
        fetchHeatData(document.getElementById('heat-points').value, null, null, null, null, heatMinValue, heatMaxValue, true);
      }
    }

    function fetchCircleData(limit, startDate, startTime, endDate, endTime, minVal, maxVal, resetView = false) {
      document.getElementById('detector-light').setAttribute('fill', '#ef4444');
      circleMinValue = minVal;
      circleMaxValue = maxVal;

      const channelId = '2955808';
      const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?results=${limit}`;

      fetch(url)
        .then(res => res.json())
        .then(data => {
          data.feeds.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
          circleMarkers.clearLayers();

          const times = [];
          const values = [];
          let sumLat = 0, sumLon = 0, count = 0;
          circleLatestValidFeed = null;

          const startTimeObj = startDate && startTime ? new Date(`${startDate}T${startTime}`) : null;
          const endTimeObj = endDate && endTime ? new Date(`${endDate}T${endTime}`) : null;

          data.feeds.forEach(feed => {
            const feedTime = new Date(feed.created_at);
            if ((startTimeObj && feedTime < startTimeObj) || (endTimeObj && feedTime > endTimeObj)) {
              return; // Skip if outside time range
            }

            const lat = parseFloat(feed.field4);
            const lon = parseFloat(feed.field5);
            const val = parseFloat(feed.field3);
            const time = feed.created_at;

            if (!isNaN(lat) && !isNaN(lon) && lat >= 20.5 && lat <= 26.7 && lon >= 88 && lon <= 92.7) {
              if (!isNaN(val) && val >= minVal && val <= maxVal) {
                times.push(time);
                values.push(val);
              }

              L.circleMarker([lat, lon], {
                radius: 6,
                fillColor: getColor(val, minVal, maxVal),
                color: '#2d3748',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
              }).addTo(circleMarkers).bindPopup(`Radiation: ${val} µSv/h<br>Time: ${time}`);

              sumLat += lat;
              sumLon += lon;
              count++;

              if (!isNaN(val)) {
                circleLatestValidFeed = feed;
              }
            }
          });

          const latest = data.feeds[data.feeds.length - 1];
          const latestVal = parseFloat(latest?.field3);
          document.getElementById('detector-display').textContent = isNaN(latestVal) ? 'N/A µSv/h' : `${latestVal.toFixed(3)} µSv/h`;
          document.getElementById('detector-light').setAttribute('fill', isNaN(latestVal) ? '#edf2f7' : getColor(latestVal, minVal, maxVal));

          circleRadiationChart.data.labels = times;
          circleRadiationChart.data.datasets[0].data = values;
          circleRadiationChart.update();

          updateLegend(minVal, maxVal, true);

          if ((circleIsInitialLoad || resetView) && count > 0) {
            circleMap.setView([sumLat / count, sumLon / count], 13);
            circleIsInitialLoad = false;
          }
        })
        .catch(console.error)
        .finally(() => {
          const latestVal = parseFloat(circleLatestValidFeed?.field3);
          document.getElementById('detector-light').setAttribute('fill', isNaN(latestVal) ? '#edf2f7' : getColor(latestVal, minVal, maxVal));
        });
    }

    function fetchHeatData(limit, startDate, startTime, endDate, endTime, minVal, maxVal, resetView = false) {
      heatMinValue = minVal;
      heatMaxValue = maxVal;

      const channelId = '2955808';
      const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?results=${limit}`;

      fetch(url)
        .then(res => res.json())
        .then(data => {
          data.feeds.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
          const heatPoints = [];
          const times = [];
          const values = [];
          let sumLat = 0, sumLon = 0, count = 0;
          heatLatestValidFeed = null;
          heatDataPoints = []; // Clear previous data points

          const startTimeObj = startDate && startTime ? new Date(`${startDate}T${startTime}`) : null;
          const endTimeObj = endDate && endTime ? new Date(`${endDate}T${endTime}`) : null;

          data.feeds.forEach(feed => {
            const feedTime = new Date(feed.created_at);
            if ((startTimeObj && feedTime < startTimeObj) || (endTimeObj && feedTime > endTimeObj)) {
              return; // Skip if outside time range
            }

            const lat = parseFloat(feed.field4);
            const lon = parseFloat(feed.field5);
            const val = parseFloat(feed.field3);
            const time = feed.created_at;

            if (!isNaN(lat) && !isNaN(lon) && lat >= 20.5 && lat <= 26.7 && lon >= 88 && lon <= 92.7) {
              if (!isNaN(val) && val >= minVal && val <= maxVal) {
                times.push(time);
                values.push(val);
                const intensity = (val - minVal) / (maxVal - minVal); // Normalize to 0-1
                heatPoints.push([lat, lon, intensity]);
                heatDataPoints.push({ lat, lon, val, time }); // Store data point
              }

              sumLat += lat;
              sumLon += lon;
              count++;

              if (!isNaN(val)) {
                heatLatestValidFeed = feed;
              }
            }
          });

          heatLayer.setLatLngs(heatPoints);

          heatRadiationChart.data.labels = times;
          heatRadiationChart.data.datasets[0].data = values;
          heatRadiationChart.update();

          updateLegend(minVal, maxVal, false);

          if ((heatIsInitialLoad || resetView) && count > 0) {
            heatMap.setView([sumLat / count, sumLon / count], 13);
            heatIsInitialLoad = false;
          }
        })
        .catch(console.error);
    }

    function searchCircleData() {
      const limit = parseInt(document.getElementById('circle-points').value);
      const startDate = document.getElementById('circle-start-date').value;
      const startTime = document.getElementById('circle-start-time').value;
      const endDate = document.getElementById('circle-end-date').value;
      const endTime = document.getElementById('circle-end-time').value;
      const minVal = parseFloat(document.getElementById('circle-min-value').value);
      const maxVal = parseFloat(document.getElementById('circle-max-value').value);

      if (limit < 1 || limit > 8000) {
        alert('Please enter a number between 1 and 8000 for Circle Map.');
        return;
      }
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      if ((startDate || startTime) && (endDate || endTime)) {
        const startTimeObj = new Date(`${startDate}T${startTime || '00:00'}`);
        const endTimeObj = new Date(`${endDate}T${endTime || '23:59'}`);
        if (startTimeObj > endTimeObj) {
          alert('Start time must be before end time.');
          return;
        }
      }
      fetchCircleData(limit, startDate, startTime, endDate, endTime, minVal, maxVal, true);
    }

    function searchHeatData() {
      const limit = parseInt(document.getElementById('heat-points').value);
      const startDate = document.getElementById('heat-start-date').value;
      const startTime = document.getElementById('heat-start-time').value;
      const endDate = document.getElementById('heat-end-date').value;
      const endTime = document.getElementById('heat-end-time').value;
      const minVal = parseFloat(document.getElementById('heat-min-value').value);
      const maxVal = parseFloat(document.getElementById('heat-max-value').value);

      if (limit < 1 || limit > 8000) {
        alert('Please enter a number between 1 and 8000 for Heatmap.');
        return;
      }
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      if ((startDate || startTime) && (endDate || endTime)) {
        const startTimeObj = new Date(`${startDate}T${startTime || '00:00'}`);
        const endTimeObj = new Date(`${endDate}T${endTime || '23:59'}`);
        if (startTimeObj > endTimeObj) {
          alert('Start time must be before end time.');
          return;
        }
      }
      fetchHeatData(limit, startDate, startTime, endDate, endTime, minVal, maxVal, true);
    }

    function updateCircleMap() {
      const val = parseInt(document.getElementById('circle-points').value);
      const minVal = parseFloat(document.getElementById('circle-min-value').value);
      const maxVal = parseFloat(document.getElementById('circle-max-value').value);
      if (val < 1 || val > 8000) {
        alert('Please enter a number between 1 and 8000 for Circle Map.');
        return;
      }
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      fetchCircleData(val, null, null, null, null, minVal, maxVal, true);
    }

    function updateHeatMap() {
      const val = parseInt(document.getElementById('heat-points').value);
      const minVal = parseFloat(document.getElementById('heat-min-value').value);
      const maxVal = parseFloat(document.getElementById('heat-max-value').value);
      if (val < 1 || val > 8000) {
        alert('Please enter a number between 1 and 8000 for Heatmap.');
        return;
      }
      if (minVal >= maxVal) {
        alert('Minimum value must be less than maximum value.');
        return;
      }
      fetchHeatData(val, null, null, null, null, minVal, maxVal, true);
    }

    fetchCircleData(8000, null, null, null, null, 0, 10, true);
    fetchHeatData(8000, null, null, null, null, 0, 10, true);
    setInterval(() => {
      const startDate = document.getElementById('circle-start-date').value || document.getElementById('heat-start-date').value;
      const endDate = document.getElementById('circle-end-date').value || document.getElementById('heat-end-date').value;
      if (!startDate && !endDate) {
        fetchCircleData(document.getElementById('circle-points').value, null, null, null, null, circleMinValue, circleMaxValue, false);
        fetchHeatData(document.getElementById('heat-points').value, null, null, null, null, heatMinValue, heatMaxValue, false);
      }
    }, 5000);
  </script>
</body>
</html>
